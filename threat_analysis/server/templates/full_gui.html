<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphical Threat Model Editor - Offline Mode</title>
    <script>
        // Configure mxGraph paths before loading the library
        var mxBasePath = '/static/js/lib';
        var mxImageBasePath = '/static/js/lib/images';
    </script>
    <script type="text/javascript" src="/static/js/lib/mxgraph.min.js"></script>
    <script src="/static/js/lib/split.min.js"></script>
    <script src="/static/js/lib/svg-pan-zoom.min.js"></script>
    <script src="/static/js/export_manager.js"></script>
    <style>
        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #F0F2F5;
        }

        .header {
            background-color: #ffffff;
            padding: 10px 20px;
            border-bottom: 1px solid #d1d5da;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            height: 40px; /* Fixed height */
        }
        .header h1 { font-size: 1.5em; margin: 0; }
        .button-group button {
            background-color: #2c974b;
            color: white; border: none; padding: 8px 16px;
            border-radius: 6px; cursor: pointer; font-size: 14px;
            margin-left: 10px; transition: background-color 0.2s;
        }
        .button-group button:hover { background-color: #278341; }
        #container { display: flex; width: 100%; height: calc(100vh - 61px); }
        .split { display: flex; flex-direction: row; width: 100%; }
        .gutter { background-color: #eee; background-repeat: no-repeat; background-position: 50%; }
        .gutter.gutter-horizontal { cursor: col-resize; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAeCAYAAADkftS9AAAAIklEQVQoU2M4c+bMfxl79uz5T5Gj5WBGjma8+fABAF0pIxXTG4ToAAAAAElFTkSuQmCC'); }
        #toolbar, #properties-panel {
            padding: 15px; box-sizing: border-box;
            background-color: #f8f9fa;
            overflow-y: auto;
        }
        #graph-container { 
            flex-grow: 1;
            position: relative;
            background-color: #fff;
            border-left: 1px solid #d1d5da;
            border-right: 1px solid #d1d5da;
        }
        #toolbar h2, #properties-panel h2 { 
            font-size: 1.2em; margin-top: 0; padding-bottom: 10px;
            border-bottom: 1px solid #e0e0e0;
        }
        .toolbar-button { 
            display: block; width: 100%; margin-bottom: 10px;
            padding: 10px; box-sizing: border-box; cursor: pointer;
            text-align: left; background-color: #fff; border: 1px solid #ccc;
            border-radius: 5px; font-size: 14px;
        }
        .toolbar-button:hover { background-color: #f0f0f0; }
        .toolbar-separator { 
            height: 1px; background-color: #e0e0e0; margin: 15px 0;
        }
        #properties-panel input, #properties-panel select, #properties-panel textarea { 
            width: 100%; padding: 8px; box-sizing: border-box;
            border: 1px solid #ccc; border-radius: 4px;
        }
        #properties-panel label { display: block; margin-top: 15px; font-size: 0.9em; font-weight: bold; margin-bottom: 5px; }
        .tab-bar { display: flex; border-bottom: 1px solid #ccc; }
        .tab-button { 
            padding: 10px 15px; cursor: pointer; background-color: #f1f1f1;
            border: none; border-bottom: 3px solid transparent;
        }
        .tab-button.active { background-color: #fff; border-bottom: 3px solid #2c974b; }
        .tab-content { display: none; padding-top: 15px; }
        .tab-content.active { display: block; }
        #analysis-result-container, #legend-container {
            height: calc(100% - 50px); overflow-y: auto;
            background-color: #fff; padding: 10px; border: 1px solid #ccc;
        }
        .prop-group { margin-bottom: 15px; }
        
        /* Export menu styles */
        .export-container {
            position: relative;
            display: inline-block;
            margin-left: 10px;
        }
        
        .export-btn {
            background-color: #4CAF50;
            color: white; border: none;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 4px;
            font-family: inherit;
        }
        
        .export-btn:hover { background-color: #45a049; }
        
        .export-menu {
            display: none;
            position: absolute;
            background-color: #f9f9f9;
            min-width: 200px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            border-radius: 4px;
            overflow: hidden;
            right: 0;
        }
        
        .export-option {
            color: black;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .export-option:hover { background-color: #e7f3ff; }
        
        .export-option:first-child {
            border-top-left-radius: 4px;
            border-top-right-radius: 4px;
        }
        
        .export-option:last-child {
            border-bottom-left-radius: 4px;
            border-bottom-right-radius: 4px;
        }
        
        /* Loading spinner for exports */
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid #4CAF50;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        /* Modal styles */
        .modal {
            display: none; 
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgb(0,0,0); 
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 700px;
            border-radius: 8px;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        #model-list-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin: 20px 0;
        }
        .model-list-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }
        .model-list-item:hover {
            background-color: #f0f0f0;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Graphical Editor</h1>
        <div class="button-group">
            <button id="open-model-btn">Open Model</button>
            <button id="analyze-btn">Generate</button>
            <div class="export-container">
                <button id="export-btn" class="export-btn">üì• Export</button>
                <div id="export-menu" class="export-menu">
                    <div class="export-option" onclick="exportModel('svg')">üìä SVG Diagram</div>
                    <div class="export-option" onclick="exportModel('diagram')">üñºÔ∏è HTML Diagram</div>
                    <div class="export-option" onclick="exportModel('report')">üìÑ HTML Report</div>
                    <div class="export-option" onclick="exportModel('json')">üìã JSON Analysis</div>
                    <div class="export-option" onclick="exportModel('markdown')">üìù Markdown</div>
                </div>
            </div>
        </div>
    </div>
    <div id="container" class="split">
        <div id="toolbar" style="width: 200px;">
            <h2>Elements</h2>
            <button class="toolbar-button" id="add-boundary">Add Boundary</button>
            <button class="toolbar-button" id="add-actor">Add Actor</button>
            <button class="toolbar-button" id="add-data">Add Data</button>
            <div class="toolbar-separator"></div>
            <button class="toolbar-button" id="add-server">Generic Server</button>
            <button class="toolbar-button" id="add-web-server">Web Server</button>
            <button class="toolbar-button" id="add-database">Database</button>
            <button class="toolbar-button" id="add-firewall">Firewall</button>
            <button class="toolbar-button" id="add-switch">Switch</button>
        </div>
        <div id="graph-container"></div>
        <div id="properties-panel" style="width: 350px;">
            <div class="tab-bar">
                <button class="tab-button active" data-tab="properties">Properties</button>
                <button class="tab-button" data-tab="analysis">Analysis</button>
            </div>
            <div id="properties" class="tab-content active">
                <h2>Element Properties</h2>
                <div id="properties-form" style="display: none;">
                    <div class="prop-group">
                        <label for="prop-name">Name:</label>
                        <input type="text" id="prop-name" />
                    </div>
                    <div class="prop-group">
                        <label for="prop-color">Color:</label>
                        <input type="color" id="prop-color" />
                    </div>
                    <div class="prop-group" id="prop-description-group">
                        <label for="prop-description">Description:</label>
                        <textarea id="prop-description" rows="3"></textarea>
                    </div>
                    <div class="prop-group" id="prop-os-group">
                        <label for="prop-os">OS:</label>
                        <input type="text" id="prop-os" />
                    </div>
                    <div class="prop-group" id="prop-stereotype-group">
                        <label for="prop-stereotype">Stereotype:</label>
                        <input type="text" id="prop-stereotype" />
                    </div>
                    <div class="prop-group" id="prop-is-filled-group">
                        <label for="prop-is-filled">Is Filled:</label>
                        <input type="checkbox" id="prop-is-filled" />
                    </div>
                    <div class="prop-group" id="prop-is-trusted-group">
                        <label for="prop-is-trusted">Is Trusted:</label>
                        <input type="checkbox" id="prop-is-trusted" />
                    </div>
                    <div class="prop-group" id="prop-line-style-group">
                        <label for="prop-line-style">Line Style:</label>
                        <select id="prop-line-style">
                            <option value="solid">Solid</option>
                            <option value="dashed">Dashed</option>
                            <option value="dotted">Dotted</option>
                        </select>
                    </div>
                    <div class="prop-group" id="prop-format-group">
                        <label for="prop-format">Format:</label>
                        <input type="text" id="prop-format" />
                    </div>
                    <div class="prop-group" id="prop-credentials-life-group">
                        <label for="prop-credentials-life">Credentials Life:</label>
                        <input type="text" id="prop-credentials-life" />
                    </div>
                    <div class="prop-group" id="prop-classification-group">
                        <label for="prop-classification">Classification:</label>
                        <select id="prop-classification">
                            <option value="public">Public</option>
                            <option value="confidential">Confidential</option>
                            <option value="secret">Secret</option>
                            <option value="top-secret">Top Secret</option>
                        </select>
                    </div>
                    <div class="prop-group" id="prop-cia-group">
                        <label>CIA:</label>
                        <select id="prop-confidentiality">
                            <option value="low">C: Low</option>
                            <option value="medium">C: Medium</option>
                            <option value="high">C: High</option>
                            <option value="critical">C: Critical</option>
                        </select>
                        <select id="prop-integrity">
                            <option value="low">I: Low</option>
                            <option value="medium">I: Medium</option>
                            <option value="high">I: High</option>
                            <option value="critical">I: Critical</option>
                        </select>
                        <select id="prop-availability">
                            <option value="low">A: Low</option>
                            <option value="medium">A: Medium</option>
                            <option value="high">A: High</option>
                            <option value="critical">A: Critical</option>
                        </select>
                    </div>
                </div>
                <div id="edge-properties-form" style="display: none;">
                    <div class="prop-group">
                        <label for="edge-prop-name">Name:</label>
                        <input type="text" id="edge-prop-name" />
                    </div>
                    <div class="prop-group">
                        <label for="edge-prop-protocol">Protocol:</label>
                        <input type="text" id="edge-prop-protocol" />
                    </div>
                    <div class="prop-group">
                        <label for="edge-prop-src-port">Source Port:</label>
                        <input type="number" id="edge-prop-src-port" />
                    </div>
                    <div class="prop-group">
                        <label for="edge-prop-dst-port">Destination Port:</label>
                        <input type="number" id="edge-prop-dst-port" />
                    </div>
                    <div class="prop-group">
                        <label for="edge-prop-data">Data:</label>
                        <input type="text" id="edge-prop-data" />
                    </div>
                    <div class="prop-group">
                        <label for="edge-prop-is-encrypted">Is Encrypted:</label>
                        <input type="checkbox" id="edge-prop-is-encrypted" />
                    </div>
                    <div class="prop-group">
                        <label for="edge-prop-is-authenticated">Is Authenticated:</label>
                        <input type="checkbox" id="edge-prop-is-authenticated" />
                    </div>
                    <div class="prop-group">
                        <label for="edge-prop-is-bidirectional">Is Bidirectional:</label>
                        <input type="checkbox" id="edge-prop-is-bidirectional" />
                    </div>
                </div>
                 <div id="no-selection">Select an element to see its properties.</div>
            </div>
            <div id="analysis" class="tab-content">
                <h2>Analysis Result</h2>
                <div id="analysis-result-container">Analysis results will appear here.</div>
                <h2>Legend</h2>
                <div id="legend-container">Legend will appear here.</div>
            </div>
        </div>
    </div>

    <div id="open-model-modal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Open Threat Model</h2>
            <div id="model-list-container">
                <p>Loading models...</p>
            </div>
            <button id="refresh-models-btn">Refresh</button>
            <button id="open-from-computer-btn">Open from computer</button>
            <input type="file" id="file-input" multiple accept=".md,.json" style="display: none;">
        </div>
    </div>

    <script type="text/javascript">
        // Register Service Worker for offline-only mode
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('/static/js/sw.js').then(function(registration) {
                    console.log('ServiceWorker registration successful - Offline mode activated');
                }, function(err) {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            const graphContainer = document.getElementById('graph-container');
            const propertiesForm = document.getElementById('properties-form');
            const noSelectionDiv = document.getElementById('no-selection');
            const nameInput = document.getElementById('prop-name');
            const colorInput = document.getElementById('prop-color');
            const descriptionInput = document.getElementById('prop-description');
            const osInput = document.getElementById('prop-os');
            const stereotypeInput = document.getElementById('prop-stereotype');
            const isFilledInput = document.getElementById('prop-is-filled');
            const isTrustedInput = document.getElementById('prop-is-trusted');
            const lineStyleInput = document.getElementById('prop-line-style');
            const formatInput = document.getElementById('prop-format');
            const credentialsLifeInput = document.getElementById('prop-credentials-life');
            const classificationInput = document.getElementById('prop-classification');

            const confidentialityInput = document.getElementById('prop-confidentiality');
            const integrityInput = document.getElementById('prop-integrity');
            const availabilityInput = document.getElementById('prop-availability');

            const edgeNameInput = document.getElementById('edge-prop-name');
            const edgeProtocolInput = document.getElementById('edge-prop-protocol');
            const edgeSrcPortInput = document.getElementById('edge-prop-src-port');
            const edgeDstPortInput = document.getElementById('edge-prop-dst-port');
            const edgeDataInput = document.getElementById('edge-prop-data');
            const edgeIsEncryptedInput = document.getElementById('edge-prop-is-encrypted');
            const edgeIsAuthenticatedInput = document.getElementById('edge-prop-is-authenticated');
            const edgeIsBidirectionalInput = document.getElementById('edge-prop-is-bidirectional');

            const analysisResultContainer = document.getElementById('analysis-result-container');
            const legendContainer = document.getElementById('legend-container');
            let panZoomInstance;
            let debounceTimer;
            let graph;
            let threatModelJSON = {};

            const styleMap = {
                'BOUNDARY': 'boundaries', 'ACTOR': 'actors', 'SERVER': 'servers',
                'WEB_SERVER': 'servers', 'DATABASE': 'servers', 'FIREWALL': 'servers',
                'ROUTER': 'servers', 'SWITCH': 'servers', 'API_GATEWAY': 'servers',
                'DATA': 'data'
            };


            console.log('DOMContentLoaded - Starting initialization');

            Split(['#toolbar', '#graph-container', '#properties-panel'], {
                sizes: [15, 60, 25], minSize: [150, 300, 300], gutterSize: 8,
            });

            console.log('Split initialized');

            try {
                if (typeof mxEvent === 'undefined') {
                    console.error('mxEvent is not defined. mxgraph library failed to load.');
                    return;
                }
                
                if (typeof mxGraph === 'undefined') {
                    console.error('mxGraph is not defined. mxgraph library failed to load.');
                    return;
                }
                
                mxEvent.disableContextMenu(graphContainer);
                console.log('mxEvent disabled context menu');
                graph = new mxGraph(graphContainer);
                console.log('mxGraph created successfully');
                graph.setPanning(true);

                // Enable zooming with mouse wheel
                mxEvent.addMouseWheelListener(function (evt, up) {
                    // Holding down Alt key is not required for zooming
                    if (up) {
                        graph.zoomIn();
                    } else {
                        graph.zoomOut();
                    }
                    mxEvent.consume(evt);
                }, graphContainer);

            new mxRubberband(graph);
            graph.setTooltips(true);
            graph.setConnectable(true);
            graph.setAllowDanglingEdges(false);
            graph.isCellFoldable = (cell) => cell.isVertex() && cell.getStyle()?.includes('BOUNDARY');

            graph.createGroupCell = function(cells) {
                const group = mxGraph.prototype.createGroupCell.apply(this, arguments);
                group.setStyle('BOUNDARY');
                return group;
            };

            const stylesheet = graph.getStylesheet();
            stylesheet.putCellStyle('BOUNDARY', { shape: mxConstants.SHAPE_RECTANGLE, dashed: 1, fillColor: '#f8f9fa', strokeColor: '#adb5bd', fontColor: '#495057', fontSize: 14, fontStyle: mxConstants.FONT_BOLD, verticalAlign: 'top', align: 'left', spacingLeft: 4, swimlane: true });
            stylesheet.putCellStyle('ACTOR', { shape: mxConstants.SHAPE_IMAGE, image: '/static/resources/icons/actor.png', verticalLabelPosition: 'bottom', verticalAlign: 'top', imageAspect: 0, fillColor: '#E9D5FF', strokeColor: '#9333EA', fontColor: '#581C87' });
            stylesheet.putCellStyle('DATA', { shape: mxConstants.SHAPE_CYLINDER, fillColor: '#FFE0B2', strokeColor: '#E65100', fontColor: '#BF360C', gradientColor: '#FFCC80', gradientDirection: mxConstants.DIRECTION_EAST, });
            stylesheet.putCellStyle('SERVER', { shape: mxConstants.SHAPE_RECTANGLE, fillColor: '#D1FAE5', strokeColor: '#065F46', fontColor: '#064E3B' });
            stylesheet.putCellStyle('ROUTER', { shape: mxConstants.SHAPE_RECTANGLE, fillColor: '#FFD700', strokeColor: '#B8860B', fontColor: '#8B4513' });
            stylesheet.putCellStyle('SWITCH', { shape: mxConstants.SHAPE_RHOMBUS, fillColor: 'orange', strokeColor: '#B8860B', fontColor: '#8B4513' });
            stylesheet.putCellStyle('API_GATEWAY', { shape: mxConstants.SHAPE_RECTANGLE, fillColor: 'lightyellow', strokeColor: '#B8860B', fontColor: '#8B4513' });

            stylesheet.putCellStyle('WEB_SERVER', { shape: mxConstants.SHAPE_IMAGE, image: '/static/resources/icons/web-server.png', verticalLabelPosition: 'bottom', verticalAlign: 'top', imageAspect: 0, fillColor: '#D1FAE5', strokeColor: '#065F46', fontColor: '#064E3B' });
            stylesheet.putCellStyle('DATABASE', { shape: mxConstants.SHAPE_IMAGE, image: '/static/resources/icons/database.png', verticalLabelPosition: 'bottom', verticalAlign: 'top', imageAspect: 0, fillColor: '#D1FAE5', strokeColor: '#065F46', fontColor: '#064E3B' });
            stylesheet.putCellStyle('FIREWALL', { shape: mxConstants.SHAPE_IMAGE, image: '/static/resources/icons/firewall.png', verticalLabelPosition: 'bottom', verticalAlign: 'top', imageAspect: 0, fillColor: '#FFCDD2', strokeColor: '#B71C1C', fontColor: '#B71C1C' });

            const parent = graph.getDefaultParent();

            // Custom function to convert our XML user data to display label
            graph.convertValueToString = function(cell) {
                if (cell && cell.value && cell.value.nodeType === Node.ELEMENT_NODE) {
                    // This is our XML object, extract the label attribute
                    return cell.value.getAttribute('label') || 'Unnamed';
                }
                return mxGraph.prototype.convertValueToString.apply(this, arguments);
            };

            graph.getModel().addListener(mxEvent.CHANGE, (model, event) => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(analyzeModelForPreview, 800);
            });

            graph.getSelectionModel().addListener(mxEvent.CHANGE, (sender, evt) => {
                updatePropertiesPanel(graph.getSelectionCell());
            });

            // Add listener for when editing stops (user finishes editing text directly on the diagram)
            graph.addListener(mxEvent.EDITING_STOPPED, (sender, evt) => {
                const cell = graph.getSelectionCell();
                if (cell) {
                    // When user edits text directly on the diagram, update the user data
                    const newLabel = graph.getLabel(cell);
                    const userData = getCellUserData(cell);
                    userData.setAttribute('label', newLabel);
                    graph.getModel().setValue(cell, userData);
                    
                    // Update the properties panel to reflect the change
                    nameInput.value = newLabel;
                }
            });

            nameInput.addEventListener('input', (evt) => updateCellProperty('label', evt.target.value));
            colorInput.addEventListener('input', (evt) => updateCellProperty('fillColor', evt.target.value));
            descriptionInput.addEventListener('input', (evt) => updateCellProperty('description', evt.target.value));
            osInput.addEventListener('input', (evt) => updateCellProperty('os', evt.target.value));
            stereotypeInput.addEventListener('input', (evt) => updateCellProperty('stereotype', evt.target.value));
            isFilledInput.addEventListener('change', (evt) => updateCellProperty('isFilled', evt.target.checked));
            isTrustedInput.addEventListener('change', (evt) => updateCellProperty('isTrusted', evt.target.checked));
            lineStyleInput.addEventListener('change', (evt) => updateCellProperty('lineStyle', evt.target.value));
            formatInput.addEventListener('input', (evt) => updateCellProperty('format', evt.target.value));
            credentialsLifeInput.addEventListener('input', (evt) => updateCellProperty('credentialsLife', evt.target.value));
            classificationInput.addEventListener('change', (evt) => updateCellProperty('classification', evt.target.value));

            confidentialityInput.addEventListener('change', (evt) => updateCellProperty('confidentiality', evt.target.value));
            integrityInput.addEventListener('change', (evt) => updateCellProperty('integrity', evt.target.value));
            availabilityInput.addEventListener('change', (evt) => updateCellProperty('availability', evt.target.value));

            edgeNameInput.addEventListener('input', (evt) => updateCellProperty('label', evt.target.value));
            edgeProtocolInput.addEventListener('input', (evt) => updateCellProperty('protocol', evt.target.value));
            edgeSrcPortInput.addEventListener('input', (evt) => updateCellProperty('srcPort', evt.target.value));
            edgeDstPortInput.addEventListener('input', (evt) => updateCellProperty('dstPort', evt.target.value));
            edgeDataInput.addEventListener('input', (evt) => updateCellProperty('data', evt.target.value));
            edgeIsEncryptedInput.addEventListener('change', (evt) => updateCellProperty('isEncrypted', evt.target.checked));
            edgeIsAuthenticatedInput.addEventListener('change', (evt) => updateCellProperty('isAuthenticated', evt.target.checked));
            edgeIsBidirectionalInput.addEventListener('change', (evt) => updateCellProperty('bidirectional', evt.target.checked));


            document.getElementById('analyze-btn').addEventListener('click', generate);
            
            // Initialize ExportManager
            const exportManager = new ExportManager(analysisResultContainer, threatModelJSON, convert_json_to_markdown);
            exportManager.initialize('export-btn', 'export-menu');
            
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', () => {
                    document.querySelectorAll('.tab-button, .tab-content').forEach(el => el.classList.remove('active'));
                    button.classList.add('active');
                    document.getElementById(button.dataset.tab).classList.add('active');
                });
            });


            function getCellUserData(cell) {
                if (cell && cell.value && typeof cell.value === 'object') {
                    return cell.value;
                }
                const doc = mxUtils.createXmlDocument();
                const obj = doc.createElement('object');
                obj.setAttribute('label', cell.value || '');
                return obj;
            }

            function updatePropertiesPanel(cell) {
                if (cell && cell.isVertex()) {
                    propertiesForm.style.display = 'block';
                    document.getElementById('edge-properties-form').style.display = 'none';
                    noSelectionDiv.style.display = 'none';
                    
                    const userData = getCellUserData(cell);
                    
                    // Set all values
                    nameInput.value = graph.convertValueToString(cell);
                    descriptionInput.value = userData.getAttribute('description', '');
                    osInput.value = userData.getAttribute('os', '');
                    const styleString = cell.getStyle();
                    let type = '';
                    for (const key in styleMap) {
                        if (styleString.includes(key)) {
                            type = key;
                            break;
                        }
                    }
                    stereotypeInput.value = userData.getAttribute('stereotype', type);
                    
                    const isFilled = userData.getAttribute('isFilled', 'true') === 'true';
                    isFilledInput.checked = isFilled;
                    if (!isFilled) {
                        graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, 'none', [cell]);
                    }

                    const isTrusted = userData.getAttribute('isTrusted', 'true') === 'true';
                    isTrustedInput.checked = isTrusted;
                    lineStyleInput.value = userData.getAttribute('lineStyle', '');
                    formatInput.value = userData.getAttribute('format', '');
                    credentialsLifeInput.value = userData.getAttribute('credentialsLife', '');
                    classificationInput.value = userData.getAttribute('classification', 'public');
                    confidentialityInput.value = userData.getAttribute('confidentiality', 'medium');
                    integrityInput.value = userData.getAttribute('integrity', 'medium');
                    availabilityInput.value = userData.getAttribute('availability', 'medium');
                    
                    const styleObject = graph.getCellStyle(cell);
                    colorInput.value = styleObject[mxConstants.STYLE_FILLCOLOR] || '#ffffff';

                    const targetStrokeColor = isTrusted ? '#adb5bd' : 'red';
                    const targetStrokeWidth = isTrusted ? '2' : '1';

                    if (styleObject[mxConstants.STYLE_STROKECOLOR] !== targetStrokeColor) {
                        graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, targetStrokeColor, [cell]);
                    }
                    if (styleObject[mxConstants.STYLE_STROKEWIDTH] !== targetStrokeWidth) {
                        graph.setCellStyles(mxConstants.STYLE_STROKEWIDTH, targetStrokeWidth, [cell]);
                    }

                    // Show/hide properties based on cell type
                    const isIconBased = styleString.includes('FIREWALL') || styleString.includes('SWITCH') || styleString.includes('DATABASE') || styleString.includes('WEB_SERVER') || styleString.includes('ACTOR');
                    document.getElementById('prop-color').parentElement.style.display = isIconBased ? 'none' : 'block';

                    const isData = styleString.includes('DATA');
                    const isServer = styleString.includes('SERVER');
                    const isBoundary = styleString.includes('BOUNDARY');
                    const isActor = styleString.includes('ACTOR');
                    
                    document.getElementById('prop-classification-group').style.display = isData ? 'block' : 'none';
                    document.getElementById('prop-os-group').style.display = isServer ? 'block' : 'none';
                    document.getElementById('prop-stereotype-group').style.display = isServer ? 'block' : 'none';
                    document.getElementById('prop-is-filled-group').style.display = isBoundary || isActor ? 'block' : 'none';
                    document.getElementById('prop-is-trusted-group').style.display = isBoundary ? 'block' : 'none';
                    document.getElementById('prop-line-style-group').style.display = isBoundary ? 'block' : 'none';
                    document.getElementById('prop-format-group').style.display = isData ? 'block' : 'none';
                    document.getElementById('prop-credentials-life-group').style.display = isData ? 'block' : 'none';
                } else if (cell && cell.isEdge()) {
                    propertiesForm.style.display = 'none';
                    document.getElementById('edge-properties-form').style.display = 'block';
                    noSelectionDiv.style.display = 'none';
                    
                    const userData = getCellUserData(cell);
                    edgeNameInput.value = graph.convertValueToString(cell);
                    edgeProtocolInput.value = userData.getAttribute('protocol', '');
                    edgeSrcPortInput.value = userData.getAttribute('srcPort', '');
                    edgeDstPortInput.value = userData.getAttribute('dstPort', '');
                    edgeDataInput.value = userData.getAttribute('data', '');
                    edgeIsEncryptedInput.checked = userData.getAttribute('isEncrypted', 'false') === 'true';
                    edgeIsAuthenticatedInput.checked = userData.getAttribute('isAuthenticated', 'false') === 'true';
                    edgeIsBidirectionalInput.checked = userData.getAttribute('bidirectional', 'false') === 'true';
                } else {
                    propertiesForm.style.display = 'none';
                    document.getElementById('edge-properties-form').style.display = 'none';
                    noSelectionDiv.style.display = 'block';
                }
            }

            function updateCellProperty(key, value) {
                const cell = graph.getSelectionCell();
                if (cell) {
                    graph.getModel().beginUpdate();
                    try {
                        const userData = getCellUserData(cell);
                        if (key === 'fillColor') {
                            graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, value, [cell]);
                        } else if (key === 'stereotype') {
                            userData.setAttribute('type', value);
                            userData.setAttribute('stereotype', value);
                            graph.getModel().setValue(cell, userData);
                            graph.setCellStyle(value.toUpperCase());
                        } else if (key === 'isFilled') {
                            const color = colorInput.value;
                            graph.setCellStyles(mxConstants.STYLE_FILLCOLOR, value ? color : 'none', [cell]);
                            userData.setAttribute(key, String(value));
                            graph.getModel().setValue(cell, userData);
                        } else if (key === 'lineStyle') {
                            userData.setAttribute(key, value);
                            graph.getModel().setValue(cell, userData);

                            if (value === 'dashed') {
                                graph.setCellStyles(mxConstants.STYLE_DASHED, '1', [cell]);
                                graph.setCellStyles(mxConstants.STYLE_DASH_PATTERN, null, [cell]);
                            } else if (value === 'dotted') {
                                graph.setCellStyles(mxConstants.STYLE_DASHED, '1', [cell]);
                                graph.setCellStyles(mxConstants.STYLE_DASH_PATTERN, '1 1', [cell]);
                            } else { // solid
                                graph.setCellStyles(mxConstants.STYLE_DASHED, '0', [cell]);
                                graph.setCellStyles(mxConstants.STYLE_DASH_PATTERN, null, [cell]);
                            }
                        } else if (key === 'isTrusted') {
                            userData.setAttribute(key, String(value));
                            graph.getModel().setValue(cell, userData);
                            if (value) { // isTrusted is true
                                graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, '#adb5bd', [cell]);
                                graph.setCellStyles(mxConstants.STYLE_STROKEWIDTH, '2', [cell]);
                            } else { // isTrusted is false
                                graph.setCellStyles(mxConstants.STYLE_STROKECOLOR, 'red', [cell]);
                                graph.setCellStyles(mxConstants.STYLE_STROKEWIDTH, '1', [cell]);
                            }
                        } else {
                            userData.setAttribute(key, value);
                            graph.getModel().setValue(cell, userData);
                            
                            // If we're updating the label, also update the displayed label
                            if (key === 'label') {
                                // Update the user data
                                userData.setAttribute(key, value);
                                graph.getModel().setValue(cell, userData);
                                
                                // Force refresh to ensure the new label is displayed
                                graph.refresh(cell);
                            }
                        }
                    } finally {
                        graph.getModel().endUpdate();
                    }
                }
            }

            const addVertex = (style, name, width, height) => {
                console.log(`Adding vertex: style=${style}, name=${name}, width=${width}, height=${height}`);
                
                const targetParent = graph.getSelectionCell()?.getStyle()?.includes('BOUNDARY') ? graph.getSelectionCell() : parent;
                console.log(`Target parent: ${targetParent ? targetParent.id : 'root'}`);
                
                graph.getModel().beginUpdate();
                try {
                    const doc = mxUtils.createXmlDocument();
                    const obj = doc.createElement('object');
                    obj.setAttribute('label', name);
                    if (style === 'BOUNDARY') {
                        obj.setAttribute('isFilled', 'true');
                        obj.setAttribute('isTrusted', 'true');
                    }
                    obj.setAttribute('stereotype', style);
                    console.log(`Created XML object with label: ${name}`);
                    
                    const v = graph.insertVertex(targetParent, null, obj, 20, 20, width, height, style);
                    console.log(`Inserted vertex: ${v ? v.id : 'null'}`);
                    
                    if (v) {
                        graph.setSelectionCell(v);
                        console.log('Set selection cell');
                    } else {
                        console.error('Failed to insert vertex');
                    }
                } finally {
                    graph.getModel().endUpdate();
                    console.log('Graph update completed');
                }
            };

            document.getElementById('add-boundary').addEventListener('click', () => {
                console.log('Add Boundary button clicked');
                try {
                    addVertex('BOUNDARY', 'New Boundary', 400, 300);
                    console.log('Add Boundary completed successfully');
                } catch (error) {
                    console.error('Error adding boundary:', error);
                }
            });
            document.getElementById('add-actor').addEventListener('click', () => {
                console.log('Add Actor button clicked');
                try {
                    addVertex('ACTOR', 'New Actor', 80, 80);
                    console.log('Add Actor completed successfully');
                } catch (error) {
                    console.error('Error adding actor:', error);
                }
            });
            document.getElementById('add-data').addEventListener('click', () => {
                console.log('Add Data button clicked');
                try {
                    addVertex('DATA', 'New Data', 100, 80);
                    console.log('Add Data completed successfully');
                } catch (error) {
                    console.error('Error adding data:', error);
                }
            });
            document.getElementById('add-server').addEventListener('click', () => {
                console.log('Add Server button clicked');
                try {
                    addVertex('SERVER', 'New Server', 140, 70);
                    console.log('Add Server completed successfully');
                } catch (error) {
                    console.error('Error adding server:', error);
                }
            });
            document.getElementById('add-web-server').addEventListener('click', () => {
                console.log('Add Web Server button clicked');
                try {
                    addVertex('WEB_SERVER', 'Web Server', 100, 100);
                    console.log('Add Web Server completed successfully');
                } catch (error) {
                    console.error('Error adding web server:', error);
                }
            });
            document.getElementById('add-database').addEventListener('click', () => {
                console.log('Add Database button clicked');
                try {
                    addVertex('DATABASE', 'Database', 100, 100);
                    console.log('Add Database completed successfully');
                } catch (error) {
                    console.error('Error adding database:', error);
                }
            });
            document.getElementById('add-firewall').addEventListener('click', () => {
                console.log('Add Firewall button clicked');
                try {
                    addVertex('FIREWALL', 'Firewall', 100, 100);
                    console.log('Add Firewall completed successfully');
                } catch (error) {
                    console.error('Error adding firewall:', error);
                }
            });
            document.getElementById('add-switch').addEventListener('click', () => {
                console.log('Add Switch button clicked');
                try {
                    addVertex('SWITCH', 'New Switch', 100, 100);
                    console.log('Add Switch completed successfully');
                } catch (error) {
                    console.error('Error adding switch:', error);
                }
            });

            } catch (e) {
                console.error("An error occurred during graph initialization:", e);
            }


            function convert_json_to_markdown(data) {
                const markdown_lines = ["# Threat Model: Graphical Editor"];

                const boundaries = data.boundaries || [];
                const actors = data.actors || [];
                const servers = data.servers || [];
                const data_elements = data.data || [];
                const dataflows = data.dataflows || [];

                const boundary_map = boundaries.reduce((acc, b) => {
                    acc[b.id] = b.name;
                    return acc;
                }, {});

                const _format_properties = (item, props_to_include) => {
                    const props = [];
                    for (const prop_key of props_to_include) {
                        const prop_value = item[prop_key];
                        if (prop_value) {
                            props.push(`${prop_key}="${prop_value}"`);
                        }
                    }
                    return props.join(', ');
                };

                markdown_lines.push("\n## Boundaries");
                for (const boundary of boundaries) {
                    const props_str = _format_properties(boundary, ['description', 'isTrusted', 'lineStyle']);
                    markdown_lines.push(`- **${boundary.name}**: ${props_str}`);
                }

                markdown_lines.push("\n## Actors");
                for (const actor of actors) {
                    const props = { 'boundary': boundary_map[actor.parentId] };
                    const props_str = _format_properties({ ...actor, ...props }, ['boundary', 'description']);
                    markdown_lines.push(`- **${actor.name}**: ${props_str}`);
                }

                markdown_lines.push("\n## Servers");
                for (const server of (data.servers || [])) {
                    const server_with_type = {...server, type: server.stereotype};
                    const props = { 'boundary': boundary_map[server_with_type.parentId] };
                    const props_str = _format_properties({ ...server_with_type, ...props }, ['boundary', 'description', 'os', 'type']);
                    markdown_lines.push(`- **${server_with_type.name}**: ${props_str}`);
                }

                markdown_lines.push("\n## Data");
                for (const data_item of data_elements) {
                    const props_str = _format_properties(data_item, ['description', 'classification', 'format', 'credentialsLife', 'confidentiality', 'integrity', 'availability']);
                    markdown_lines.push(`- **${data_item.name}**: ${props_str}`);
                }

                markdown_lines.push("\n## Dataflows");
                const nodes = [...actors, ...servers, ...data_elements].reduce((acc, item) => {
                    acc[item.id] = item;
                    return acc;
                }, {});
                for (const df of dataflows) {
                    const from_node = nodes[df.from];
                    const to_node = nodes[df.to];
                    if (from_node && to_node) {
                        const df_name = df.name || `${from_node.name} to ${to_node.name}`;
                        const props_str = _format_properties(df, ['protocol', 'description', 'srcPort', 'dstPort', 'data', 'isEncrypted', 'isAuthenticated', 'bidirectional']);
                        markdown_lines.push(`- **${df_name}**: from="${from_node.name}", to="${to_node.name}", ${props_str}`);
                    }
                }

                return markdown_lines.join('\n');
            }

            function getModelName(markdownContent) {
                const match = markdownContent.match(/^# Threat Model: (.*)$/m);
                return match ? match[1].trim() : "Untitled Model";
            }

            function generate() {
                if (panZoomInstance && analysisResultContainer.querySelector('svg')) {
                    panZoomInstance.destroy();
                    panZoomInstance = null;
                }

                const model = graph.getModel();
                const defaultParent = graph.getDefaultParent();
                const cells = model.getChildCells(defaultParent, true, true);
                console.log("Number of cells found:", cells.length);

                const positions = { boundaries: {}, actors: {}, servers: {}, dataflows: {} };
                const threatModelJSON = { boundaries: [], actors: [], servers: [], data: [], dataflows: [] };

                cells.forEach(cell => {
                    const parentCell = cell.getParent();
                    const parentId = (parentCell && parentCell.id !== '0' && parentCell.id !== '1' ) ? parentCell.id : null;
                    const style = cell.getStyle();
                    const userData = getCellUserData(cell);
                    const label = userData.getAttribute('label', '') || graph.convertValueToString(cell);

                    if (cell.isVertex()) {
                        const geometry = cell.getGeometry();
                        const props = {
                            id: cell.id, name: label, parentId: parentId,
                            description: userData.getAttribute('description', ''),
                            os: userData.getAttribute('os', ''),
                            stereotype: userData.getAttribute('stereotype', ''),
                            isFilled: userData.getAttribute('isFilled', 'false'),
                            isTrusted: userData.getAttribute('isTrusted', 'false'),
                            lineStyle: userData.getAttribute('lineStyle', ''),
                            format: userData.getAttribute('format', ''),
                            credentialsLife: userData.getAttribute('credentialsLife', ''),
                            classification: userData.getAttribute('classification', 'public'),
                            confidentiality: userData.getAttribute('confidentiality', 'medium'),
                            integrity: userData.getAttribute('integrity', 'medium'),
                            availability: userData.getAttribute('availability', 'medium')
                        };

                        const styleKeys = Object.keys(styleMap).sort((a, b) => b.length - a.length);
                        for (const key of styleKeys) {
                            if (style.includes(key)) {
                                if (!props.stereotype) {
                                    props.stereotype = key;
                                }
                                const category = styleMap[key];
                                 if (category === 'data' && !positions.data) {
                                    positions.data = {};
                                }
                                threatModelJSON[category].push({ ...props, type: key });
                                if (positions[category]) {
                                    positions[category][label.toLowerCase()] = { x: geometry.x, y: geometry.y, width: geometry.width, height: geometry.height };
                                }
                                break;
                            }
                        }
                    } else if (cell.isEdge()) {
                        const geometry = cell.getGeometry();
                        const df_name = label || 'Dataflow';
                        threatModelJSON.dataflows.push({
                            id: cell.id, name: df_name,
                            from: cell.source?.id, to: cell.target?.id,
                            protocol: userData.getAttribute('protocol', ''),
                            srcPort: userData.getAttribute('srcPort', ''),
                            dstPort: userData.getAttribute('dstPort', ''),
                            data: userData.getAttribute('data', ''),
                            isEncrypted: userData.getAttribute('isEncrypted', 'false'),
                            isAuthenticated: userData.getAttribute('isAuthenticated', 'false'),
                            bidirectional: userData.getAttribute('bidirectional', 'false')
                        });
                        if (geometry && geometry.points) {
                            positions.dataflows[df_name.toLowerCase()] = { points: geometry.points };
                        }
                    }
                });

                console.log("Threat Model JSON for generate:", threatModelJSON);
                console.log("Positions for generate:", positions);
                const markdownContent = convert_json_to_markdown(threatModelJSON);
                const modelName = getModelName(markdownContent);

                fetch('/api/generate_all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ markdown: markdownContent, model_name: modelName, positions: positions })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        analysisResultContainer.innerHTML = `<div style="color: red;">Error: ${data.error}</div>`;
                        return;
                    }

                    let generatedFilesHtml = '<h3>Generated Files:</h3><ul>';
                    for (const key in data.generated_files) {
                        if (typeof data.generated_files[key] === 'string') {
                            generatedFilesHtml += `<li>${key}: <code>${data.generated_files[key]}</code></li>`;
                        } else {
                            generatedFilesHtml += `<li>${key}:<ul>`;
                            for (const subKey in data.generated_files[key]) {
                                generatedFilesHtml += `<li>${subKey}: <code>${data.generated_files[key][subKey]}</code></li>`;
                            }
                            generatedFilesHtml += `</ul></li>`;
                        }
                    }
                    generatedFilesHtml += '</ul>';


                    analysisResultContainer.innerHTML = `
                        <div style="padding: 10px; background-color: #e7f3ff; border-left: 4px solid #2196F3;">
                            <strong>‚úÖ All artifacts generated successfully in:</strong> <code>${data.generation_dir}</code>
                        </div>
                        ${generatedFilesHtml}
                    `;
                    legendContainer.innerHTML = '';
                })
                .catch(error => {
                    console.error('Error:', error);
                    analysisResultContainer.innerHTML = `<div style="color: red;">An error occurred while generating the project.</div>`;
                });
            }

            document.getElementById('analyze-btn').addEventListener('click', generate);

            // Debounced analysis for live updates
            graph.getModel().addListener(mxEvent.CHANGE, (model, event) => {
                clearTimeout(debounceTimer);
                // We don't want to call generate on every change, so we can keep the old analyzeModel for the live preview
                // or disable it if we only want to generate on button click.
                // For now, let's keep a lighter version of analyzeModel for live updates.
                // debounceTimer = setTimeout(analyzeModelForPreview, 800);
            });

            function analyzeModelForPreview() {
                // This function can be a slimmed down version of analyzeModel that only fetches the diagram
                // and doesn't trigger the full generation. For now, we can leave it empty to disable live updates.
            }
            
            const openModelModal = document.getElementById('open-model-modal');
            const openModelBtn = document.getElementById('open-model-btn');
            const closeBtn = openModelModal.querySelector('.close-button');
            const modelListContainer = document.getElementById('model-list-container');
            const refreshModelsBtn = document.getElementById('refresh-models-btn');
            const openFromComputerBtn = document.getElementById('open-from-computer-btn');
            const fileInput = document.getElementById('file-input');

            openFromComputerBtn.onclick = () => {
                fileInput.click();
            };

            fileInput.onchange = (event) => {
                console.log("fileInput.onchange triggered");
                const files = event.target.files;
                if (files.length === 0) {
                    return;
                }

                let markdownFile = null;
                let metadataFile = null;

                // Find the first markdown file
                for (let i = 0; i < files.length; i++) {
                    if (files[i].name.endsWith('.md')) {
                        markdownFile = files[i];
                        break;
                    }
                }

                if (!markdownFile) {
                    alert('Please select a markdown (.md) file.');
                    return;
                }

                // Look for a corresponding metadata file
                const expectedMetadataName = markdownFile.name.replace('.md', '_metadata.json');
                for (let i = 0; i < files.length; i++) {
                    if (files[i].name === expectedMetadataName) {
                        metadataFile = files[i];
                        break;
                    }
                }
                
                // If no specific metadata file, take the first json
                if (!metadataFile) {
                    for (let i = 0; i < files.length; i++) {
                        if (files[i].name.endsWith('.json')) {
                            metadataFile = files[i];
                            break;
                        }
                    }
                }

                const markdownReader = new FileReader();
                markdownReader.onload = (e) => {
                    const markdownContent = e.target.result;

                    if (metadataFile) {
                        const metadataReader = new FileReader();
                        metadataReader.onload = (me) => {
                            try {
                                const metadataContent = JSON.parse(me.target.result);
                                repopulateGraph(markdownContent, metadataContent);
                                openModelModal.style.display = 'none';
                            } catch (jsonError) {
                                alert('Error parsing metadata file. Loading model without metadata.');
                                repopulateGraph(markdownContent, null);
                                openModelModal.style.display = 'none';
                            }
                        };
                        metadataReader.readAsText(metadataFile);
                    } else {
                        console.log("No metadata file selected. Loading without positions.");
                        alert("No metadata file was selected.\n\nFor security reasons, the browser cannot automatically load the metadata file from your computer.\n\nPlease select both the .md file and its corresponding _metadata.json file at the same time to load the positions.");
                        repopulateGraph(markdownContent, null);
                        openModelModal.style.display = 'none';
                    }
                };
                markdownReader.readAsText(markdownFile);
            };

            openModelBtn.onclick = () => {
                openModelModal.style.display = 'block';
                fetchModels();
            };
            closeBtn.onclick = () => {
                openModelModal.style.display = 'none';
            };
            window.onclick = (event) => {
                if (event.target == openModelModal) {
                    openModelModal.style.display = 'none';
                }
            };
            refreshModelsBtn.onclick = fetchModels;

            function fetchModels() {
                console.log("fetchModels called");
                modelListContainer.innerHTML = '<p>Loading models...</p>';
                fetch('/api/models')
                    .then(response => response.json())
                    .then(data => {
                        if (data.error) {
                            modelListContainer.innerHTML = `<p style="color: red;">Error: ${data.error}</p>`;
                            return;
                        }
                        modelListContainer.innerHTML = '';
                        if (data.models.length === 0) {
                            modelListContainer.innerHTML = '<p>No saved models found.</p>';
                        } else {
                            data.models.forEach(modelPath => {
                                console.log("Creating list item for:", modelPath);
                                const item = document.createElement('div');
                                item.className = 'model-list-item';
                                item.textContent = modelPath;
                                item.onclick = () => loadModel(modelPath);
                                modelListContainer.appendChild(item);
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching models:', error);
                        modelListContainer.innerHTML = '<p style="color: red;">Failed to fetch models.</p>';
                    });
            }

            function loadModel(modelPath) {
                console.log("Loading model:", modelPath);
                fetch('/api/load_model', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model_path: modelPath })
                })
                .then(response => response.json())
                .then(data => {
                    console.log("Data from /api/load_model:", JSON.stringify(data, null, 2));
                    if (data.error) {
                        alert(`Error loading model: ${data.error}`);
                        return;
                    }
                    if (!data.metadata) {
                        console.error("Metadata is null or undefined in the response from /api/load_model");
                    }
                    repopulateGraph(data.markdown_content, data.metadata);
                    openModelModal.style.display = 'none';
                })
                .catch(error => {
                    console.error('Error loading model:', error);
                    alert('Failed to load model.');
                });
            }

            function repopulateGraph(markdown, metadata) {
                console.log("repopulateGraph called with metadata:", JSON.stringify(metadata, null, 2));
                
                // New logic: Convert position keys to lowercase if metadata exists
                let processedPositions = null;
                if (metadata && metadata.positions) {
                    processedPositions = {};
                    for (const category in metadata.positions) {
                        processedPositions[category] = {};
                        for (const name in metadata.positions[category]) {
                            processedPositions[category][name.toLowerCase()] = metadata.positions[category][name];
                        }
                    }
                }

                fetch('/api/markdown_to_json', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ markdown: markdown })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert(`Error converting model: ${data.error}`);
                        return;
                    }
                    drawGraphFromJSON(data.model_json, processedPositions); // Use processedPositions
                })
                .catch(error => {
                    console.error('Error converting model:', error);
                    alert('Failed to convert model.');
                });
            }

            function drawGraphFromJSON(modelJSON, positions) {
                console.log("Drawing graph from JSON. modelJSON:", JSON.stringify(modelJSON, null, 2));
                console.log("Positions:", JSON.stringify(positions, null, 2));

                graph.getModel().beginUpdate();
                try {
                    graph.removeCells(graph.getChildVertices(graph.getDefaultParent()));
                    const cellMap = {}; // Maps model ID to mxGraph cell
                    const parent = graph.getDefaultParent();

                    // Create boundaries first
                    const boundaryTree = [];
                    const boundaryMap = {};
                    if (modelJSON.boundaries) {
                        modelJSON.boundaries.forEach(b => {
                            boundaryMap[b.id] = { ...b, children: [] };
                        });
                        modelJSON.boundaries.forEach(b => {
                            if (b.parentId && boundaryMap[b.parentId]) {
                                boundaryMap[b.parentId].children.push(boundaryMap[b.id]);
                            } else {
                                boundaryTree.push(boundaryMap[b.id]);
                            }
                        });
                    }

                    function createBoundaryVertices(boundaries, parentCell) {
                        boundaries.forEach(b => {
                            const pos = positions?.boundaries?.[b.name.toLowerCase()] || { x: 20, y: 20, width: 400, height: 300 };
                            console.log("Position for boundary", b.name, ":", pos);
                            
                            let relativeX = pos.x;
                            let relativeY = pos.y;
                            if (parentCell && parentCell !== parent) {
                                const parentGeo = graph.getCellGeometry(parentCell);
                                if (parentGeo) {
                                    relativeX -= parentGeo.x;
                                    relativeY -= parentGeo.y;
                                }
                            }

                            const doc = mxUtils.createXmlDocument();
                            const obj = doc.createElement('object');
                            obj.setAttribute('label', b.name);
                            obj.setAttribute('description', b.description);
                            obj.setAttribute('isTrusted', String(b.isTrusted));
                            obj.setAttribute('lineStyle', b.lineStyle);

                            const v = graph.insertVertex(parentCell, null, obj, relativeX, relativeY, pos.width, pos.height, 'BOUNDARY');
                            cellMap[b.id] = v;
                            createBoundaryVertices(b.children, v);
                        });
                    }

                    createBoundaryVertices(boundaryTree, parent);

                    ['actors', 'servers', 'data'].forEach(type => {
                        if (modelJSON[type]) {
                            modelJSON[type].forEach(elem => {
                                const pos = positions?.[type]?.[elem.name.toLowerCase()] || { x: 20, y: 20, width: 80, height: 80 };
                                console.log(`Position for ${type}`, elem.name, ":", pos);

                                let style;
                                const stereotype = elem.type || elem.stereotype;
                                if (type === 'servers') {
                                    style = (stereotype || 'SERVER').toUpperCase();
                                } else {
                                    style = type.slice(0, -1).toUpperCase();
                                }
                                if (type === 'data') style = 'DATA';
                                if (type === 'actors') style = 'ACTOR';


                                const parentCell = elem.parentId ? cellMap[elem.parentId] : parent;
                                let relativeX = pos.x;
                                let relativeY = pos.y;

                                if (parentCell && parentCell !== parent) {
                                    const parentGeo = graph.getCellGeometry(parentCell);
                                    if (parentGeo) {
                                        relativeX -= parentGeo.x;
                                        relativeY -= parentGeo.y;
                                    }
                                }

                                const doc = mxUtils.createXmlDocument();
                                const obj = doc.createElement('object');
                                obj.setAttribute('label', elem.name);
                                obj.setAttribute('description', elem.description);
                                if(elem.os) obj.setAttribute('os', elem.os);
                                if(stereotype) {
                                    obj.setAttribute('stereotype', stereotype);
                                }
                                
                                const v = graph.insertVertex(parentCell, null, obj, relativeX, relativeY, pos.width, pos.height, style);
                                cellMap[elem.id] = v;
                            });
                        }
                    });

                    // Create dataflows
                    if (modelJSON.dataflows) {
                        modelJSON.dataflows.forEach(df => {
                            const fromCell = cellMap[df.from];
                            const toCell = cellMap[df.to];
                            if (fromCell && toCell) {
                                const doc = mxUtils.createXmlDocument();
                                const obj = doc.createElement('object');
                                obj.setAttribute('label', df.name);
                                obj.setAttribute('protocol', df.protocol);
                                obj.setAttribute('description', df.description);
                                obj.setAttribute('isEncrypted', String(df.isEncrypted));
                                obj.setAttribute('isAuthenticated', String(df.isAuthenticated));

                                const edge = graph.insertEdge(parent, null, obj, fromCell, toCell);
                                
                                const pos = positions?.dataflows?.[df.name.toLowerCase()];
                                if (pos && pos.points) {
                                    const geo = graph.getCellGeometry(edge);
                                    if(geo) {
                                        geo.points = pos.points;
                                    }
                                }
                            }
                        });
                    }

                } finally {
                    graph.getModel().endUpdate();
                }
            }
            
            analyzeModelForPreview(); // Initial analysis for preview
        });
    </script>
</html>
